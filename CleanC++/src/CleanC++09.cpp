// 9 设计模式和习惯用法
// 9.1 设计原则及设计模式
// 9.2 常见的设计模式及应用场景
// 9.2.1 依赖注入(Dependency Injection,DI)
// 依赖注入是敏捷架构的关键元素。将组件与其需要的服务分离，这样组件就不必知道这些服务的名称，也不必知道如何获取它们。
// 依赖倒置，控制反转
// 能够促进松耦合
// 9.2.2 Adapter模式
// 把一个类的接口转换为客户端期望的另一个接口。Adapter可以让因接口不兼容而无法一起工作的类一起工作。
// 9.2.3 Strategy模式
// 定义一组算法，然后封装每个算法，并使它们可以相互替换。策略模式允许算法独立于使用它的客户端而变化。
// 9.2.4 Command模式
// 将请求封装为对象，从而允许你使用不同的请求、队列或日志的请求参数化客户端或支持可撤销操作。
// 9.2.5 Command处理器模式
// 9.2.6 Composite模式
// 将对象组合称树结构来表示“部分-整体”的层次结构。组合允许客户端统一地处理单个对象和对象的组合。
// 9.2.7 Observer模式
// 定义对象之间一对多的依赖关系，以便在一个对象更改状态时，自动通知并更新其所有的依赖关系。
// 9.2.8 Factory模式
// 9.2.10 Facade模式
// 为子系统中的一组接口提供统一的接口。Facade定义了一个更高级的接口，使得子系统更容易使用。
// 9.2.10 Money Class模式
// 9.2.11 特例模式
// 9.3 什么是习惯用法
// Include Guard,Macro Guard, Header Guard
#ifndef __FILENAME__H__
#define __FILENAME__H__
//...
#endif __FILENAME__H__
#pragma once
// 一些习惯用法
// 不可变的类
// 匹配失败不是错误(SFINAE:Substitution Failure is not an Error)
// std::enable_if
// Copy-and-Swap习惯用法
// 指向实现的指针(Handle Body手法)：
// 通过将内部类的实现细节重新定位到隐藏的实现类中，消除对实现的编译依赖，从而提高编译时间。